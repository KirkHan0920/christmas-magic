<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="åœ£è¯é­”æ³•">
    <meta name="theme-color" content="#00ff88">
    <meta name="description" content="3Dåœ£è¯æ ‘å’Œçˆ±å¿ƒé­”æ³•æ•ˆæœï¼Œæ‰‹åŠ¿æ§åˆ¶">
    
    <title>åœ£è¯å¿«ä¹å‘€ï¼</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif; touch-action: manipulation; -webkit-user-select: none; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        .controls { pointer-events: auto; padding: 15px; display: flex; gap: 10px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); flex-wrap: wrap; }
        
        @media (max-width: 768px) {
            .controls { padding: 10px; gap: 8px; }
        }

        /* ç§»é™¤äº† file-upload ç›¸å…³æ ·å¼ */
        button { background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); color: white; padding: 10px 20px; border-radius: 30px; cursor: pointer; backdrop-filter: blur(10px); transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; font-size: 12px; display: flex; align-items: center; justify-content: center; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        button:hover, button:active { background: rgba(255, 255, 255, 0.3); box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); }
        
        @media (max-width: 768px) {
            button { padding: 8px 16px; font-size: 11px; }
        }

        /* å¯åŠ¨é®ç½©å±‚ */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100; pointer-events: auto;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #start-btn {
            font-size: 20px; padding: 15px 40px; border: 2px solid #00ff88; color: #00ff88;
            background: transparent; box-shadow: 0 0 20px rgba(0,255,136, 0.2);
            cursor: pointer; margin-top: 20px;
        }
        #start-btn:hover { background: #00ff88; color: black; }
        #debug-log {
            color: #ffcc00; margin-top: 20px; font-size: 14px;
        }
        #blessing-input {
            padding: 12px; width: 80%; max-width: 400px;
            border: 1px solid #00ff88; border-radius: 5px;
            background: rgba(255, 255, 255, 0.1); color: white;
            font-size: 16px; margin-top: 20px;
            -webkit-appearance: none; appearance: none;
            touch-action: manipulation;
        }
        
        @media (max-width: 768px) {
            #blessing-input { font-size: 14px; padding: 10px; width: 90%; }
        }

        /* è§†é¢‘é¢„è§ˆ */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px; border-radius: 10px;
            transform: scaleX(-1); border: 2px solid rgba(255,255,255,0.2);
            opacity: 0.7; z-index: 11; pointer-events: none; object-fit: cover;
        }

        .status {
            position: absolute; top: 80px; left: 20px;
            color: #00ff88; font-size: 14px; text-shadow: 0 0 5px #00ff88;
        }
        
        /* ç¥ç¦è¯­æ˜¾ç¤ºå±‚ */
        #blessing-display {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff9900;
            font-size: 4vw;
            font-weight: bold;
            text-shadow: 0 0 10px #ffcc00, 0 0 20px rgba(255, 153, 0, 0.5);
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.5s ease;
            text-align: center;
            line-height: 1.2;
            z-index: 12;
            white-space: pre-wrap;
            padding: 0 20px;
            word-wrap: break-word;
        }
        
        @media (max-width: 768px) {
            #blessing-display { font-size: 6vw; padding: 0 15px; }
        }
        
        @media (max-width: 480px) {
            #blessing-display { font-size: 7vw; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>head>
<body>
    <!-- èƒŒæ™¯éŸ³ä¹ (å¯é€‰) -->
    <!-- <audio id="background-music" loop>
        <source src="music/1.mp3" type="audio/mp3"> 
    </audio> -->

    <div id="start-overlay">
        <h1 style="color:white; margin-bottom: 20px;">ğŸ„ 3D åœ£è¯ & çˆ±å¿ƒé­”æ³• - å¯åŠ¨</h1>
        <input type="text" id="blessing-input" placeholder="è¾“å…¥æ‚¨çš„ç¥ç¦è¯­ (ä¾‹å¦‚: åœ£è¯å¿«ä¹! çˆ±ä½ å“Ÿ!)" value="ğŸ„ åœ£è¯å¿«ä¹! æ„¿æœ›æˆçœŸ! â¤ï¸">
        <button id="start-btn">å¼€å¯æ‘„åƒå¤´ä½“éªŒ</button>
        <p id="debug-log">ç­‰å¾…ç”¨æˆ·ç‚¹å‡»å¼€å§‹...</p>
    </div>
    
    <div id="ui-layer">
        <div class="controls">
            <button id="music-btn">ğŸµ æ’­æ”¾éŸ³ä¹</button>
            <button id="fullscreen-btn">å…¨å±æ¨¡å¼</button>
            <!-- ç§»é™¤äº†ä¸Šä¼ ç…§ç‰‡æŒ‰é’® -->
        </div>
        <div class="status" id="gesture-status">æœªå¯åŠ¨</div>
    </div>

    <div id="blessing-display"></div>

    <video id="video-preview" playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap'; 
        
        let scene, camera, renderer, composer, controls;
        let particles = []; 
        let time = 0;
        let handsModel;
        let videoElement;
        const debugLog = document.getElementById('debug-log');
        
        // çŠ¶æ€å®šä¹‰ï¼šå¢åŠ  HEART æ¨¡å¼
        const STATE = { mode: 'SCATTER', handPresent: false };
        const SETTINGS = { particleCount: 1500, treeHeight: 60, treeRadius: 25 };
        const EMOJIS = ['ğŸ', 'ğŸ””', 'â¤ï¸', 'ğŸ…', 'ğŸ„', 'ğŸª', 'â­', 'âœ¨'];

        let userBlessing = "";
        let isBlessingVisible = false;
        
        initThree();
        animate();

        // --- å¯åŠ¨æµç¨‹ ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            const blessingInput = document.getElementById('blessing-input');
            userBlessing = blessingInput.value.trim() || blessingInput.placeholder;
            
            document.getElementById('start-btn').innerText = "å¯åŠ¨ä¸­...";
            await startCameraAndAI();
        });

        async function startCameraAndAI() {
            const statusEl = document.getElementById('gesture-status');
            videoElement = document.getElementById('video-preview');

            if (typeof window.Hands === 'undefined') {
                debugLog.innerText = "é”™è¯¯: MediaPipe åŠ è½½å¤±è´¥ã€‚";
                return;
            }

            try {
                // å°è¯•æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                const bgMusic = document.getElementById('background-music');
                if (bgMusic) {
                    try {
                        await bgMusic.play();
                        debugLog.innerText = "èƒŒæ™¯éŸ³ä¹å·²å¼€å§‹æ’­æ”¾";
                    } catch (musicErr) {
                        console.warn("éŸ³ä¹è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢:", musicErr);
                        debugLog.innerText = "ç‚¹å‡»æ’­æ”¾æŒ‰é’®ä»¥å¯ç”¨èƒŒæ™¯éŸ³ä¹";
                    }
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480, facingMode: "user" } 
                });
                
                videoElement.srcObject = stream;
                await new Promise(resolve => videoElement.onloadedmetadata = () => videoElement.play().then(resolve));
                
                statusEl.innerText = "æ‘„åƒå¤´å¼€å¯ï¼ŒåŠ è½½æ¨¡å‹ä¸­...";
                
                handsModel = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`});
                handsModel.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
                handsModel.onResults(onHandsResults);
                
                document.getElementById('start-overlay').style.display = 'none';
                statusEl.innerText = "ç³»ç»Ÿè¿è¡Œä¸­ - æ¡æ‹³æˆæ ‘ï¼Œé£ŸæŒ‡å‘ä¸Šæˆçˆ±å¿ƒ";
                detectHandsLoop();

            } catch (err) {
                console.error(err);
                debugLog.innerText = `å¯åŠ¨é”™è¯¯: ${err.message}`;
                document.getElementById('start-btn').innerText = "é‡è¯•";
            }
        }

        async function detectHandsLoop() {
            if (videoElement && handsModel && videoElement.readyState >= 2) {
                await handsModel.send({image: videoElement});
            }
            requestAnimationFrame(detectHandsLoop);
        }
        
        // ================= Three.js é€»è¾‘ =================

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x050505, 0.002);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 100);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffd700, 2, 100); 
            pointLight.position.set(0, SETTINGS.treeHeight / 2 + 5, 0); scene.add(pointLight);
            
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; bloomPass.strength = 1.2; bloomPass.radius = 0.7;
            
            composer = new EffectComposer(renderer); 
            composer.addPass(renderScene); 
            composer.addPass(bloomPass);
            
            createParticles();
            
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            
            // æ·»åŠ éŸ³ä¹æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            const musicBtn = document.getElementById('music-btn');
            const bgMusic = document.getElementById('background-music');
            
            if (musicBtn && bgMusic) {
                // æ›´æ–°æŒ‰é’®æ–‡æœ¬ä»¥åæ˜ å½“å‰çŠ¶æ€
                updateMusicButtonText();
                
                musicBtn.addEventListener('click', () => {
                    if (bgMusic.paused) {
                        bgMusic.play().then(() => {
                            updateMusicButtonText();
                            debugLog.innerText = "èƒŒæ™¯éŸ³ä¹å·²æ’­æ”¾";
                        }).catch(err => {
                            console.warn("æ’­æ”¾éŸ³ä¹å¤±è´¥:", err);
                            debugLog.innerText = "æ’­æ”¾å¤±è´¥ï¼Œè¯·ç‚¹å‡»é¡µé¢ä»»æ„ä½ç½®åé‡è¯•";
                        });
                    } else {
                        bgMusic.pause();
                        updateMusicButtonText();
                        debugLog.innerText = "èƒŒæ™¯éŸ³ä¹å·²æš‚åœ";
                    }
                });
            }
            
            function updateMusicButtonText() {
                if (bgMusic.paused) {
                    musicBtn.innerHTML = 'ğŸµ æ’­æ”¾éŸ³ä¹';
                } else {
                    musicBtn.innerHTML = 'â¸ï¸ æš‚åœéŸ³ä¹';
                }
            }
        }

        // === æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ä¿®æ”¹ ===
        function onHandsResults(results) {
            const statusEl = document.getElementById('gesture-status');
            const blessingDisplay = document.getElementById('blessing-display');
            let newMode = 'SCATTER';
            STATE.handPresent = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handPresent = true;
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];

                // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ä¸¤ç‚¹è·ç¦»
                const getDist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 1. è®¡ç®—å„ä¸ªæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
                const dIndex = getDist(landmarks[8], wrist);  // é£ŸæŒ‡
                const dMiddle = getDist(landmarks[12], wrist); // ä¸­æŒ‡
                const dRing = getDist(landmarks[16], wrist);   // æ— åæŒ‡
                const dPinky = getDist(landmarks[20], wrist);  // å°æŒ‡

                // è®¡ç®—å¹³å‡è·ç¦»ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦æ¡æ‹³ï¼‰
                const avgAllDist = (dIndex + dMiddle + dRing + dPinky) / 4;
                
                // è®¡ç®—é™¤äº†é£ŸæŒ‡ä»¥å¤–çš„å¹³å‡è·ç¦»ï¼ˆç”¨äºåˆ¤æ–­æ˜¯å¦å•æŒ‡å‘ä¸Šï¼‰
                const avgOthersDist = (dMiddle + dRing + dPinky) / 3;

                // --- é€»è¾‘åˆ¤æ–­ ---
                
                // é€»è¾‘ A: å•æŒ‡å‘ä¸Š (é£ŸæŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²)
                // é£ŸæŒ‡è·ç¦»è¿œï¼Œå…¶ä»–è·ç¦»è¿‘
                if (dIndex > 0.35 && avgOthersDist < 0.25) {
                    newMode = 'HEART';
                    statusEl.innerText = "çŠ¶æ€: â˜ï¸ å•æŒ‡å‘ä¸Š (çˆ±å¿ƒèšåˆ)";
                }
                // é€»è¾‘ B: æ¡æ‹³ (æ‰€æœ‰æ‰‹æŒ‡è·ç¦»è¿‘)
                else if (avgAllDist < 0.25) {
                    newMode = 'TREE';
                    statusEl.innerText = "çŠ¶æ€: âœŠ æ¡æ‹³ (åœ£è¯æ ‘èšåˆ)";
                } 
                // é€»è¾‘ C: å…¶ä»– (å¼ å¼€)
                else {
                    newMode = 'SCATTER';
                    statusEl.innerText = "çŠ¶æ€: ğŸ– å¼ å¼€ (ç²’å­æ•£å¼€)";
                }
            } else {
                statusEl.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
            }

            // çŠ¶æ€åˆ‡æ¢ä¸ç¥ç¦è¯­æ˜¾ç¤º
            if (newMode !== STATE.mode) {
                STATE.mode = newMode;
                // åœ¨åœ£è¯æ ‘æ¨¡å¼ æˆ– çˆ±å¿ƒæ¨¡å¼ ä¸‹éƒ½æ˜¾ç¤ºç¥ç¦è¯­
                if (STATE.mode === 'TREE' || STATE.mode === 'HEART') {
                    if (userBlessing) {
                        blessingDisplay.innerText = userBlessing;
                        blessingDisplay.style.opacity = 1;
                        isBlessingVisible = true;
                    }
                } else {
                    blessingDisplay.style.opacity = 0;
                    isBlessingVisible = false;
                }
            }
        }
        
        function createParticles() {
            const geoSphere = new THREE.SphereGeometry(0.5, 16, 16);
            const geoBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const materialBase = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.2, transparent: true, opacity: 0.9 });
            
            for (let i = 0; i < SETTINGS.particleCount; i++) {
                let mesh; const type = Math.random();
                if (type < 0.3) {
                    let geo = type < 0.15 ? geoSphere : geoBox;
                    let mat = materialBase.clone(); mat.color.setHSL(Math.random(), 0.8, 0.5);
                    mesh = new THREE.Mesh(geo, mat);
                } else {
                    const emoji = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
                    const map = createEmojiTexture(emoji);
                    mesh = new THREE.Sprite(new THREE.SpriteMaterial({ map: map, transparent: true }));
                    mesh.scale.set(2, 2, 2);
                }
                
                // åˆå§‹ä½ç½®
                mesh.position.set((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                
                // --- 1. åœ£è¯æ ‘ç›®æ ‡ä½ç½® ---
                const y = (i / SETTINGS.particleCount) * SETTINGS.treeHeight - (SETTINGS.treeHeight / 2);
                const progress = (y + SETTINGS.treeHeight/2) / SETTINGS.treeHeight;
                const radius = SETTINGS.treeRadius * (1 - progress); 
                const angle = i * 0.5;
                const treePos = new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius);

                // --- 2. æ•£å¼€ä½ç½® ---
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*160, (Math.random()-0.5)*160, (Math.random()-0.5)*160);

                // --- 3. çˆ±å¿ƒç›®æ ‡ä½ç½® (æ–°åŠŸèƒ½) ---
                // çˆ±å¿ƒå‚æ•°æ–¹ç¨‹
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const t = Math.random() * Math.PI * 2;
                const heartScale = 2.5; // ç¼©æ”¾ç³»æ•°
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                // æ·»åŠ ä¸€ç‚¹éšæœºåšåº¦
                const hz = (Math.random() - 0.5) * 15; 
                
                // ç»„åˆä½ç½®ï¼Œç¨å¾®å‘ä¸Šåç§»ä¸€ç‚¹ä½¿å…¶å±…ä¸­
                const heartPos = new THREE.Vector3(
                    hx * heartScale + (Math.random()-0.5), 
                    hy * heartScale + 10 + (Math.random()-0.5), 
                    hz
                );

                mesh.userData = { 
                    treePos: treePos, 
                    scatterPos: scatterPos, 
                    heartPos: heartPos 
                };
                
                scene.add(mesh); particles.push(mesh);
            }
        }

        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d'); ctx.font = '100px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            controls.update();
            
            particles.forEach((p, i) => {
                let target = null;
                
                // æ ¹æ®æ¨¡å¼é€‰æ‹©ç›®æ ‡ä½ç½®
                if (STATE.mode === 'TREE') {
                    target = p.userData.treePos;
                } else if (STATE.mode === 'HEART') {
                    target = p.userData.heartPos; // é£å‘çˆ±å¿ƒä½ç½®
                } else {
                    // æ•£å¼€æ¨¡å¼ï¼šåšä¸€äº›æ‚¬æµ®åŠ¨ç”»
                    const os = p.userData.scatterPos;
                    const r = Math.sqrt(os.x**2 + os.z**2);
                    const a = Math.atan2(os.z, os.x) + time * 0.2;
                    target = new THREE.Vector3(Math.cos(a)*r, os.y + Math.sin(time+i)*5, Math.sin(a)*r);
                }
                
                // å¹³æ»‘ç§»åŠ¨
                p.position.lerp(target, 0.05);
                p.rotation.x += 0.01; p.rotation.y += 0.02;
            });
            
            // åœºæ™¯æ•´ä½“æ—‹è½¬
            if (STATE.mode === 'SCATTER') scene.rotation.y = Math.sin(time * 0.6) * 0.6;
            else scene.rotation.y += 0.002;
            
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }
        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
    </script>
</body>
</html>
